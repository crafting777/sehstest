// Built-in Exams Data - All exams are pre-loaded
const BUILT_IN_EXAMS = {
  "exams": [
    {
      "name": "May 2021 SEHS Paper 1 Time Zone 1",
      "questions": [
        {"question": "What are the functions of the axial skeleton?", "answers": ["muscle attachment    protection of organs    fine motor movement", "support of the body    protection of organs    fine motor movement", "support of the body    protection of organs    muscle attachment", "muscle attachment    support of the body    fine motor movement"], "correctAnswer": 2, "image": null},
        {"question": "Which statement is correct about the insertion of a skeletal muscle?", "answers": ["The attachment of a muscle tendon to a moveable bone", "The attachment of a muscle tendon to a stationary bone", "The attachment of a muscle tendon at the proximal end", "The attachment of a muscle tendon on the anterior aspect"], "correctAnswer": 0, "image": null},
        {"question": "The diagram shows the skeletal muscles in the anterior upper leg. Which muscle is labelled X?", "answers": ["Rectus femoris", "Vastus medialis", "Sartorius", "Vastus lateralis"], "correctAnswer": 3, "image": "images/may2021_q3_anterior_upper_leg.PNG"},
        {"question": "The graph below represents lung volume. What is labelled X?", "answers": ["Tidal volume", "Vital capacity", "Expiratory reserve volume", "Inspiratory reserve volume"], "correctAnswer": 1, "image": "images/may2021_q4_lung_volume.PNG"},
        {"question": "Which statement(s) about the functions of the conducting airways is/are correct?\nI. Provide a low resistance pathway for airflow\nII. Provide a site for gaseous exchange\nIII. Warm and moisten the air", "answers": ["I and II only", "I and III only", "II and III only", "I, II and III"], "correctAnswer": 1, "image": null},
        {"question": "What causes an increase in ventilation?", "answers": ["A decrease in carbon dioxide content in the blood", "A decrease in hydrogen ions in the blood", "A decrease in blood pH", "A decrease in blood acidity"], "correctAnswer": 2, "image": null},
        {"question": "What is the primary role of platelets?", "answers": ["Supporting immune function", "Carrying dissolved substances", "Transporting oxygen", "Blood clotting and preventing bleeding"], "correctAnswer": 3, "image": null},
        {"question": "How is cardiac output calculated?", "answers": ["Heart rate √ó stroke volume", "Heart rate + stroke volume", "Heart rate + tidal volume", "Tidal volume √ó stroke volume"], "correctAnswer": 0, "image": null},
        {"question": "What does systolic blood pressure measure?", "answers": ["The force exerted on venous walls during atrial contraction", "The force exerted on arterial walls during atrial contraction", "The force exerted on venous walls during ventricular contraction", "The force exerted on arterial walls during ventricular contraction"], "correctAnswer": 3, "image": null},
        {"question": "Which are macronutrients?\nI. Fats\nII. Carbohydrates\nIII. Water", "answers": ["I and II only", "I and III only", "II and III only", "I, II and III"], "correctAnswer": 3, "image": null},
        {"question": "What is the composition of triacylglycerol?", "answers": ["Three glycerol and one fatty acid molecules", "One glucose and three fatty acid molecules", "One glycerol and three fatty acid molecules", "Three glucose and one fatty acid molecules"], "correctAnswer": 2, "image": null},
        {"question": "What is a function of adrenaline?", "answers": ["Increases stimulation of the parasympathetic nervous system", "Increases heart rate", "Decreases glycogenolysis", "Decreases heart rate"], "correctAnswer": 1, "image": null},
        {"question": "What is the definition of cell respiration?", "answers": ["The controlled release of energy in the form of adenosine triphosphate (ATP) from organic compounds in cells", "The controlled release of energy in the form of adenosine diphosphate (ADP) from organic compounds in cells", "The controlled release of energy in the form of glycogen from organic compounds in cells", "The controlled release of energy in the form of carbon dioxide from organic compounds in cells"], "correctAnswer": 0, "image": null},
        {"question": "Which energy system is the predominant contributor of ATP for a runner participating in a marathon?", "answers": ["ATP‚ÄìPC system", "Anaerobic system", "Lactic acid system", "Aerobic system"], "correctAnswer": 3, "image": null},
        {"question": "What shortens during muscular contraction according to the sliding filament theory?", "answers": ["Z line", "A band", "H zone", "Actin"], "correctAnswer": 2, "image": null},
        {"question": "What is an example of an isotonic eccentric contraction for the triceps?", "answers": ["Lowering phase (elbow flexion) in a push-up", "Lifting phase (elbow extension) in a push-up", "Execution phase (elbow extension) when throwing a ball", "Preparation phase (elbow flexion) when throwing a ball"], "correctAnswer": 0, "image": null},
        {"question": "Which term describes a scalar quantity?", "answers": ["Acceleration", "Distance", "Displacement", "Velocity"], "correctAnswer": 1, "image": null},
        {"question": "What is an example of a first-class lever?", "answers": ["Triceps contracting, moving the elbow", "Biceps contracting, moving the elbow", "Quadriceps contracting, moving the knee", "Hamstrings contracting, moving the knee"], "correctAnswer": 0, "image": null},
        {"question": "How is angular momentum calculated?", "answers": ["Moment of inertia √∑ angular velocity", "Moment of inertia - angular velocity", "Moment of inertia √ó angular velocity", "Moment of inertia + angular velocity"], "correctAnswer": 2, "image": null},
        {"question": "For successful completion, which event requires the greatest angle of release?", "answers": ["High jump", "Long jump", "Shot put", "Discus"], "correctAnswer": 0, "image": null},
        {"question": "Which is an example of perceptual skill?", "answers": ["Knowledge of team tactics", "Shooting in basketball", "Assessing the putting green in golf", "Receiving a serve in tennis"], "correctAnswer": 2, "image": null},
        {"question": "What does ability refer to?", "answers": ["The production of goal-orientated movements", "The way in which a sports skill is performed", "A learned skill that is specific to the task", "The general trait or capacity of the individual"], "correctAnswer": 3, "image": null},
        {"question": "Why are yellow balls used in tennis?", "answers": ["To increase signal intensity", "To limit background noise", "To improve the efficiency of sense organs", "To improve memory retrieval"], "correctAnswer": 0, "image": null},
        {"question": "What is the average capacity of short-term memory?", "answers": ["1 bit of information", "2 ¬± 7 bits of information", "7 ¬± 2 bits of information", "Unlimited"], "correctAnswer": 2, "image": null},
        {"question": "What is Hick's Law?", "answers": ["There is an increase in reaction time with increased number of choices.", "There is a decrease in reaction time with increased number of choices.", "There is an increase in movement time with increased number of choices.", "There is a decrease in movement time with increased number of choices."], "correctAnswer": 0, "image": null},
        {"question": "Which describes practice to performance transfer in tennis?", "answers": ["Hitting against a ball machine", "Understanding the biomechanics of hitting", "Training for strength to improve hitting", "Hitting right-handed and left-handed"], "correctAnswer": 0, "image": null},
        {"question": "An athlete completed five timed trials of a 20 m sprint test. What is the mean time?\n\nTrial | Time (s)\n1 | 3.95\n2 | 4.05\n3 | 3.80\n4 | 4.00\n5 | 4.20", "answers": ["3.90 s", "3.95 s", "4.00 s", "4.05 s"], "correctAnswer": 2, "image": null},
        {"question": "What does a large standard deviation indicate?", "answers": ["The data is clustered closely to the mean.", "The data is spread widely around the mean.", "The data is normally distributed.", "The data is not normally distributed."], "correctAnswer": 1, "image": null},
        {"question": "Which fitness component does the stork stand test?", "answers": ["Reaction time", "Balance", "Strength", "Muscle endurance"], "correctAnswer": 1, "image": null},
        {"question": "Which are elements of a general training programme?\nI. Warm up\nII. Endurance training\nIII. Recreational activities and sports", "answers": ["I and II only", "I and III only", "II and III only", "I, II and III"], "correctAnswer": 3, "image": null}
      ]
    }
  ]
};

// Quiz Application State
let allQuestions = [];
let currentQuestions = [];
let currentQuestionIndex = 0;
let userAnswers = {};
let score = { correct: 0, total: 0 };
let examNames = [];
let currentMode = 'all';
let currentExamIndex = 0;
let answerMappings = {}; // Maps questionId to { shuffledAnswers, originalToShuffled, shuffledToOriginal }
let isRapidFire = false;
let rapidFireQuestions = []; // Pool of questions for rapid fire
let rapidFireAnswered = new Set(); // Track which questions have been shown
let incorrectQuestions = []; // Track incorrect questions with details

// DOM Elements
const fileInput = document.getElementById('file-input');
const uploadSection = document.getElementById('upload-section');
const quizSection = document.getElementById('quiz-section');
const resultsSection = document.getElementById('results-section');
const modeRadios = document.querySelectorAll('input[name="mode"]');
const examSelector = document.getElementById('exam-selector');
const examDropdown = document.getElementById('exam-dropdown');
const questionText = document.getElementById('question-text');
const questionImageContainer = document.getElementById('question-image-container');
const questionImage = document.getElementById('question-image');
const answerButtons = document.querySelectorAll('.answer-button');
const feedback = document.getElementById('feedback');
const prevButton = document.getElementById('prev-button');
const nextButton = document.getElementById('next-button');
const finishButton = document.getElementById('finish-button');
const questionNumber = document.getElementById('question-number');
const scoreDisplay = document.getElementById('score-display');
const progressFill = document.getElementById('progress-fill');
const resumeSection = document.getElementById('resume-section');
const resumeButton = document.getElementById('resume-button');
const clearSavedButton = document.getElementById('clear-saved-button');
const saveProgressButton = document.getElementById('save-progress-button');
const storedExamsSection = document.getElementById('stored-exams-section');
const examsList = document.getElementById('exams-list');
const backToHomeButton = document.getElementById('back-to-home-button');
const backToHomeResultsButton = document.getElementById('back-to-home-results-button');
const randomizeCheckbox = document.getElementById('randomize-checkbox');
const randomizeAnswersCheckbox = document.getElementById('randomize-answers-checkbox');
const endRapidFireButton = document.getElementById('end-rapidfire-button');
const incorrectQuestionsSection = document.getElementById('incorrect-questions-section');
const incorrectQuestionsList = document.getElementById('incorrect-questions-list');
const exportAllButton = document.getElementById('export-all-button');
const exportIncorrectButton = document.getElementById('export-incorrect-button');
const imageBaseUrlInput = document.getElementById('image-base-url-input');
const saveImageUrlButton = document.getElementById('save-image-url-button');

// Event Listeners
fileInput.addEventListener('change', handleFileUpload);
modeRadios.forEach(radio => {
    radio.addEventListener('change', handleModeChange);
});
examDropdown.addEventListener('change', handleExamChange);
answerButtons.forEach(button => {
    button.addEventListener('click', handleAnswerClick);
});
prevButton.addEventListener('click', goToPreviousQuestion);
nextButton.addEventListener('click', goToNextQuestion);
finishButton.addEventListener('click', finishQuiz);
document.getElementById('restart-button').addEventListener('click', restartQuiz);
document.getElementById('review-button').addEventListener('click', reviewAnswers);
resumeButton.addEventListener('click', resumeSavedQuiz);
clearSavedButton.addEventListener('click', clearSavedData);
saveProgressButton.addEventListener('click', saveProgress);
backToHomeButton.addEventListener('click', goBackToHome);
backToHomeResultsButton.addEventListener('click', goBackToHome);
endRapidFireButton.addEventListener('click', endRapidFire);
exportAllButton.addEventListener('click', exportAllTests);
exportIncorrectButton.addEventListener('click', exportIncorrectAnswers);
saveImageUrlButton.addEventListener('click', saveImageBaseUrl);

// Check for saved data on page load
// Dark mode toggle
const darkModeToggle = document.getElementById('dark-mode-toggle');
const darkModeIcon = document.getElementById('dark-mode-icon');

// Load dark mode preference
function loadDarkMode() {
    const isDarkMode = localStorage.getItem('darkMode') === 'true';
    if (isDarkMode) {
        document.body.classList.add('dark-mode');
        darkModeIcon.textContent = '‚òÄÔ∏è';
    } else {
        document.body.classList.remove('dark-mode');
        darkModeIcon.textContent = 'üåô';
    }
}

// Toggle dark mode
function toggleDarkMode() {
    document.body.classList.toggle('dark-mode');
    const isDarkMode = document.body.classList.contains('dark-mode');
    localStorage.setItem('darkMode', isDarkMode);
    darkModeIcon.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô';
}

// Event listener for dark mode toggle
if (darkModeToggle) {
    darkModeToggle.addEventListener('click', toggleDarkMode);
}

window.addEventListener('load', async () => {
    loadDarkMode(); // Load dark mode preference first
    await checkForSavedData();
    loadImageBaseUrl();
});
window.addEventListener('beforeunload', saveProgress);

// Storage Functions
function saveQuestionsToStorage() {
    try {
        localStorage.setItem('quizQuestions', JSON.stringify({
            allQuestions: allQuestions,
            examNames: examNames
        }));
    } catch (error) {
        console.error('Error saving questions:', error);
    }
}

function loadQuestionsFromStorage() {
    try {
        const saved = localStorage.getItem('quizQuestions');
        if (saved) {
            const data = JSON.parse(saved);
            allQuestions = data.allQuestions || [];
            examNames = data.examNames || [];
            return true;
        }
    } catch (error) {
        console.error('Error loading questions:', error);
    }
    return false;
}

function saveProgress() {
    try {
        const progressData = {
            currentQuestionIndex: currentQuestionIndex,
            userAnswers: userAnswers,
            score: score,
            currentMode: currentMode,
            currentExamIndex: currentExamIndex,
            currentQuestions: currentQuestions.map(q => q.id),
            timestamp: new Date().toISOString()
        };
        localStorage.setItem('quizProgress', JSON.stringify(progressData));
    } catch (error) {
        console.error('Error saving progress:', error);
    }
}

function loadProgress() {
    try {
        const saved = localStorage.getItem('quizProgress');
        if (saved) {
            return JSON.parse(saved);
        }
    } catch (error) {
        console.error('Error loading progress:', error);
    }
    return null;
}

// Exam scores storage functions
function saveExamScore(examName, scoreData) {
    try {
        const scores = getExamScores();
        scores[examName] = {
            percentage: scoreData.percentage,
            correct: scoreData.correct,
            total: scoreData.total,
            timestamp: new Date().toISOString(),
            date: new Date().toLocaleDateString()
        };
        localStorage.setItem('examScores', JSON.stringify(scores));
    } catch (error) {
        console.error('Error saving exam score:', error);
    }
}

function getExamScores() {
    try {
        const saved = localStorage.getItem('examScores');
        if (saved) {
            return JSON.parse(saved);
        }
    } catch (error) {
        console.error('Error loading exam scores:', error);
    }
    return {};
}

function getExamScore(examName) {
    const scores = getExamScores();
    return scores[examName] || null;
}

// Image base URL functions for Vercel/hosting
function saveImageBaseUrl() {
    const baseUrl = imageBaseUrlInput.value.trim();
    localStorage.setItem('imageBaseUrl', baseUrl);
    alert('Image base URL saved! Images will now use this base URL.');
}

function loadImageBaseUrl() {
    const savedUrl = localStorage.getItem('imageBaseUrl');
    if (savedUrl) {
        imageBaseUrlInput.value = savedUrl;
    } else {
        // Auto-detect if we're on Vercel or a hosted site
        const currentUrl = window.location.origin;
        if (currentUrl.includes('vercel.app') || currentUrl.includes('netlify.app') || 
            currentUrl.includes('github.io') || currentUrl.includes('herokuapp.com')) {
            imageBaseUrlInput.value = currentUrl + '/';
        }
    }
}

function getImageBaseUrl() {
    return localStorage.getItem('imageBaseUrl') || '';
}

function resolveImagePath(imagePath) {
    if (!imagePath || imagePath === 'null' || imagePath === null) {
        return null;
    }
    
    // If it's already a full URL or data URI, return as is
    if (imagePath.startsWith('http://') || imagePath.startsWith('https://') || imagePath.startsWith('data:')) {
        return imagePath;
    }
    
    // Get base URL
    const baseUrl = getImageBaseUrl();
    
    // If base URL is set, prepend it
    if (baseUrl) {
        // Ensure base URL ends with /
        const base = baseUrl.endsWith('/') ? baseUrl : baseUrl + '/';
        // Remove leading / from image path if present
        const cleanPath = imagePath.startsWith('/') ? imagePath.substring(1) : imagePath;
        return base + cleanPath;
    }
    
    // No base URL set, return original path (works for localhost)
    return imagePath;
}

function clearSavedData() {
    if (confirm('Are you sure you want to clear all saved questions and progress?')) {
        localStorage.removeItem('quizQuestions');
        localStorage.removeItem('quizProgress');
        localStorage.removeItem('examScores');
        allQuestions = [];
        examNames = [];
        resumeSection.style.display = 'none';
        storedExamsSection.style.display = 'none';
        location.reload();
    }
}

// Load built-in exams from embedded data file
async function loadBuiltInExams() {
    const existingQuestions = [...allQuestions];
    const existingExamNames = [...examNames];
    
    try {
        // Fetch the built-in exams data file
        const response = await fetch('built-in-exams.json');
        if (!response.ok) {
            console.log('Built-in exams file not found, skipping...');
            return;
        }
        
        const builtInExamsData = await response.json();
        
        // Process built-in exams (only add if they don't already exist)
        if (builtInExamsData.exams) {
            builtInExamsData.exams.forEach(exam => {
                const examName = exam.name || 'Unnamed Exam';
                
                // Only add if exam doesn't already exist
                if (!existingExamNames.includes(examName)) {
                    examNames.push(examName);
                    
                    exam.questions.forEach((q, idx) => {
                        allQuestions.push({
                            ...q,
                            examName: examName,
                            id: `builtin-${examName}-${idx}`
                        });
                    });
                }
            });
        }
        
        // Save to storage if we added any new exams
        if (allQuestions.length > existingQuestions.length) {
            saveQuestionsToStorage();
        }
    } catch (error) {
        console.log('Error loading built-in exams:', error);
        // Silently fail - user can still upload exams manually
    }
}

async function checkForSavedData() {
    // First load built-in exams
    await loadBuiltInExams();
    
    // Then load any saved exams (will merge, not replace)
    const hasQuestions = loadQuestionsFromStorage();
    const hasProgress = loadProgress();
    
    if (hasQuestions || allQuestions.length > 0) {
        populateExamDropdown();
        displayStoredExams();
        if (hasProgress) {
            resumeSection.style.display = 'block';
        }
    }
}

// Export all tests to a ZIP file
async function exportAllTests() {
    if (allQuestions.length === 0) {
        alert('No tests to export. Please load some questions first.');
        return;
    }
    
    // Check if JSZip is available
    if (typeof JSZip === 'undefined') {
        alert('Error: JSZip library not loaded. Please check your internet connection and refresh the page.');
        return;
    }
    
    try {
        // Group questions by exam name
        const examsData = {};
        examNames.forEach(examName => {
            examsData[examName] = {
                name: examName,
                questions: []
            };
        });
        
        // Add questions to their respective exams
        allQuestions.forEach(question => {
            const examName = question.examName || 'All Questions';
            if (!examsData[examName]) {
                examsData[examName] = {
                    name: examName,
                    questions: []
                };
            }
            
            // Remove internal properties (id, examName) and keep only original question data
            const cleanQuestion = {
                question: question.question,
                answers: question.answers,
                correctAnswer: question.correctAnswer,
                image: question.image || null
            };
            
            examsData[examName].questions.push(cleanQuestion);
        });
        
        // Create a new JSZip instance
        const zip = new JSZip();
        
        // Add each exam as a separate JSON file to the ZIP
        examNames.forEach(examName => {
            // Create export data for this exam only
            const exportData = {
                exams: [examsData[examName]]
            };
            
            // Create JSON string with pretty formatting
            const jsonString = JSON.stringify(exportData, null, 2);
            
            // Create safe filename from exam name
            const safeFileName = examName.replace(/[^a-z0-9]/gi, '_').toLowerCase() + '.json';
            
            // Add file to ZIP
            zip.file(safeFileName, jsonString);
        });
        
        // Generate the ZIP file
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        
        // Create download link
        const url = URL.createObjectURL(zipBlob);
        const link = document.createElement('a');
        link.href = url;
        
        // Create filename with current date
        const date = new Date();
        const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD format
        link.download = `all-exams-export-${dateStr}.zip`;
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Clean up
        URL.revokeObjectURL(url);
        
        alert(`Successfully exported ${examNames.length} exam(s) to ZIP file!`);
    } catch (error) {
        console.error('Error creating ZIP file:', error);
        alert('Error creating ZIP file: ' + error.message);
    }
}

// Export incorrect answers for LLM analysis
function exportIncorrectAnswers() {
    if (incorrectQuestions.length === 0) {
        alert('No incorrect answers to export.');
        return;
    }
    
    // Format data for LLM analysis
    const exportData = {
        summary: {
            totalIncorrect: incorrectQuestions.length,
            exportDate: new Date().toISOString()
        },
        incorrectQuestions: incorrectQuestions.map((item, index) => {
            // Map answer choices with labels
            const answerChoices = item.allAnswers.map((answer, idx) => {
                const label = ['A', 'B', 'C', 'D'][idx];
                return {
                    label: label,
                    text: answer,
                    isCorrect: label === item.correctAnswer,
                    isUserAnswer: label === item.userAnswer
                };
            });
            
            return {
                questionNumber: index + 1,
                question: item.question,
                answerChoices: answerChoices,
                userAnswer: {
                    label: item.userAnswer,
                    text: item.userAnswerText
                },
                correctAnswer: {
                    label: item.correctAnswer,
                    text: item.correctAnswerText
                },
                image: item.image || null
            };
        })
    };
    
    // Create JSON export
    const jsonString = JSON.stringify(exportData, null, 2);
    
    // Create text format for easy LLM pasting
    let textFormat = `INCORRECT ANSWERS ANALYSIS\n`;
    textFormat += `Total Incorrect: ${incorrectQuestions.length}\n`;
    textFormat += `Export Date: ${new Date().toLocaleString()}\n\n`;
    textFormat += `========================================\n\n`;
    
    incorrectQuestions.forEach((item, index) => {
        textFormat += `QUESTION ${index + 1}:\n`;
        textFormat += `${item.question}\n\n`;
        
        textFormat += `ANSWER CHOICES:\n`;
        item.allAnswers.forEach((answer, idx) => {
            const label = ['A', 'B', 'C', 'D'][idx];
            let marker = '  ';
            if (label === item.correctAnswer) marker = '‚úì ';
            if (label === item.userAnswer) marker = '‚úó ';
            textFormat += `${marker}${label}) ${answer}\n`;
        });
        
        textFormat += `\nMY ANSWER: ${item.userAnswer}) ${item.userAnswerText}\n`;
        textFormat += `CORRECT ANSWER: ${item.correctAnswer}) ${item.correctAnswerText}\n`;
        
        if (item.image) {
            textFormat += `IMAGE: ${item.image}\n`;
        }
        
        textFormat += `\n========================================\n\n`;
    });
    
    // Create ZIP with both formats
    if (typeof JSZip !== 'undefined') {
        createIncorrectAnswersZip(jsonString, textFormat);
    } else {
        // Fallback: just download JSON if JSZip not available
        downloadFile(jsonString, 'incorrect-answers.json', 'application/json');
        alert('Exported incorrect answers as JSON. Note: Install JSZip for text format export.');
    }
}

async function createIncorrectAnswersZip(jsonString, textFormat) {
    try {
        const zip = new JSZip();
        
        // Add JSON file
        zip.file('incorrect-answers.json', jsonString);
        
        // Add text file for easy LLM pasting
        zip.file('incorrect-answers.txt', textFormat);
        
        // Generate ZIP
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        
        // Download
        const date = new Date();
        const dateStr = date.toISOString().split('T')[0];
        downloadFile(zipBlob, `incorrect-answers-${dateStr}.zip`, 'application/zip');
        
        alert(`Successfully exported ${incorrectQuestions.length} incorrect answer(s)!\n\nThe ZIP contains:\n- incorrect-answers.json (structured data)\n- incorrect-answers.txt (easy to paste into LLMs)`);
    } catch (error) {
        console.error('Error creating ZIP:', error);
        // Fallback to JSON only
        downloadFile(jsonString, 'incorrect-answers.json', 'application/json');
        alert('Error creating ZIP. Exported JSON file instead.');
    }
}

function downloadFile(content, filename, mimeType) {
    const blob = content instanceof Blob ? content : new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

function displayStoredExams() {
    if (examNames.length === 0) {
        storedExamsSection.style.display = 'none';
        return;
    }
    
    storedExamsSection.style.display = 'block';
    examsList.innerHTML = '';
    
    // Group questions by exam name
    const examStats = {};
    examNames.forEach(examName => {
        const examQuestions = allQuestions.filter(q => q.examName === examName);
        const examScore = getExamScore(examName);
        examStats[examName] = {
            count: examQuestions.length,
            examName: examName,
            score: examScore
        };
    });
    
    if (Object.keys(examStats).length === 0) {
        examsList.innerHTML = '<div class="empty-exams-message">No exams stored yet. Load a questions file to get started!</div>';
        return;
    }
    
    // Create list items for each exam
    Object.values(examStats).forEach((exam, index) => {
        const examItem = document.createElement('div');
        examItem.className = 'exam-item';
        
        // Format score display
        let scoreDisplay = '';
        if (exam.score) {
            const scoreColor = exam.score.percentage >= 70 ? '#28a745' : exam.score.percentage >= 50 ? '#ffc107' : '#dc3545';
            scoreDisplay = `
                <div class="exam-score" style="margin-top: 8px; font-size: 0.95em;">
                    <span style="color: ${scoreColor}; font-weight: bold;">
                        üìä Last Score: ${exam.score.percentage}% (${exam.score.correct}/${exam.score.total})
                    </span>
                    <span style="color: #666; font-size: 0.85em; margin-left: 8px;">
                        ${exam.score.date}
                    </span>
                </div>
            `;
        } else {
            scoreDisplay = '<div class="exam-score" style="margin-top: 8px; font-size: 0.9em; color: #999;">No score yet</div>';
        }
        
        examItem.innerHTML = `
            <div class="exam-info">
                <div class="exam-name">${exam.examName}</div>
                <div class="exam-details">${exam.count} question${exam.count !== 1 ? 's' : ''}</div>
                ${scoreDisplay}
            </div>
            <div class="exam-actions">
                <button class="start-exam-button" data-exam-name="${exam.examName}">
                    ‚ñ∂Ô∏è Start Exam
                </button>
                <button class="delete-exam-button" data-exam-name="${exam.examName}">
                    üóëÔ∏è Delete
                </button>
            </div>
        `;
        
        // Add event listeners
        const startButton = examItem.querySelector('.start-exam-button');
        const deleteButton = examItem.querySelector('.delete-exam-button');
        startButton.addEventListener('click', () => startExamFromList(exam.examName));
        deleteButton.addEventListener('click', () => deleteExam(exam.examName));
        
        examsList.appendChild(examItem);
    });
}

function startExamFromList(examName) {
    // Set mode to exam
    document.querySelector('input[name="mode"][value="exam"]').checked = true;
    currentMode = 'exam';
    
    // Find exam index
    const examIndex = examNames.indexOf(examName);
    if (examIndex === -1) {
        alert('Exam not found.');
        return;
    }
    
    currentExamIndex = examIndex;
    
    // Set dropdown to this exam
    examDropdown.value = examIndex;
    
    isRapidFire = false;
    
    // Filter questions for this exam
    currentQuestions = allQuestions.filter(q => q.examName === examName);
    
    // Randomize questions if checkbox is checked
    if (randomizeCheckbox.checked) {
        currentQuestions = shuffleArray(currentQuestions);
    }
    
    // Reset quiz state
    currentQuestionIndex = 0;
    userAnswers = {};
    score = { correct: 0, total: 0 };
    answerMappings = {}; // Reset answer mappings for new quiz
    incorrectQuestions = []; // Reset incorrect questions tracking
    
    // Show quiz section
    uploadSection.style.display = 'none';
    quizSection.style.display = 'block';
    resultsSection.style.display = 'none';
    examSelector.style.display = 'block';
    
    // Display first question
    displayQuestion();
    updateNavigationButtons();
    updateScoreDisplay();
    
    // Save progress
    saveProgress();
}

function deleteExam(examName) {
    if (!confirm(`Are you sure you want to delete "${examName}" and all its ${allQuestions.filter(q => q.examName === examName).length} questions? This cannot be undone.`)) {
        return;
    }
    
    // Remove questions for this exam
    allQuestions = allQuestions.filter(q => q.examName !== examName);
    
    // Remove exam name from list
    examNames = examNames.filter(name => name !== examName);
    
    // Update storage
    saveQuestionsToStorage();
    
    // Clear progress if it was for this exam
    const progress = loadProgress();
    if (progress && progress.currentMode === 'exam') {
        const progressExamName = examNames[progress.currentExamIndex];
        if (!progressExamName || progressExamName !== examName) {
            // Progress is for a different exam, keep it
        } else {
            // Progress was for deleted exam, clear it
            localStorage.removeItem('quizProgress');
        }
    }
    
    // Update UI
    populateExamDropdown();
    displayStoredExams();
    
    // If we're in quiz mode and viewing this exam, go back to upload
    if (quizSection.style.display !== 'none') {
        const selectedMode = document.querySelector('input[name="mode"]:checked').value;
        if (selectedMode === 'exam') {
            const selectedExamName = examNames[parseInt(examDropdown.value)];
            if (!selectedExamName || selectedExamName === examName) {
                // We were viewing the deleted exam, go back
                quizSection.style.display = 'none';
                uploadSection.style.display = 'block';
            }
        }
    }
    
    // Update resume section
    const hasProgress = loadProgress();
    if (hasProgress) {
        resumeSection.style.display = 'block';
    } else {
        resumeSection.style.display = 'none';
    }
    
    alert(`"${examName}" has been deleted.`);
}

function resumeSavedQuiz() {
    const progress = loadProgress();
    
    if (!progress) {
        alert('No saved progress found.');
        return;
    }
    
    // Restore state
    currentQuestionIndex = progress.currentQuestionIndex || 0;
    userAnswers = progress.userAnswers || {};
    score = progress.score || { correct: 0, total: 0 };
    currentMode = progress.currentMode || 'all';
    currentExamIndex = progress.currentExamIndex || 0;
    
    // Restore mode selection
    document.querySelector(`input[name="mode"][value="${currentMode}"]`).checked = true;
    
    if (currentMode === 'exam' && examNames.length > 0) {
        examSelector.style.display = 'block';
        examDropdown.value = currentExamIndex;
        const selectedExamName = examNames[currentExamIndex];
        currentQuestions = allQuestions.filter(q => q.examName === selectedExamName);
    } else {
        examSelector.style.display = 'none';
        currentQuestions = [...allQuestions];
    }
    
    // Show quiz
    uploadSection.style.display = 'none';
    quizSection.style.display = 'block';
    resultsSection.style.display = 'none';
    
    displayQuestion();
    updateNavigationButtons();
    updateScoreDisplay();
    
    resumeSection.style.display = 'none';
}

// Handle file upload
function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            
            // Validate JSON structure
            if (!Array.isArray(data) && !data.exams) {
                throw new Error('Invalid format. Expected array of questions or object with "exams" property.');
            }

            // Load existing questions first (to merge, not replace)
            const existingQuestions = [...allQuestions];
            const existingExamNames = [...examNames];
            
            let newQuestions = [];
            let newExamNames = [];

            // Handle different formats
            if (Array.isArray(data)) {
                // Simple array format - treat as single exam
                const examName = 'All Questions';
                newQuestions = data.map((q, idx) => ({
                    ...q,
                    examName: examName,
                    id: `${examName}-${Date.now()}-${idx}`
                }));
                newExamNames = [examName];
            } else if (data.exams) {
                // Structured format with exams
                data.exams.forEach(exam => {
                    const examName = exam.name || 'Unnamed Exam';
                    
                    // Check if exam already exists
                    if (existingExamNames.includes(examName)) {
                        // Ask user if they want to replace or skip
                        if (!confirm(`An exam named "${examName}" already exists. Do you want to replace it with the new one? (Click Cancel to skip this exam)`)) {
                            return; // Skip this exam
                        }
                        // Remove existing exam
                        allQuestions = allQuestions.filter(q => q.examName !== examName);
                        examNames = examNames.filter(name => name !== examName);
                    }
                    
                    newExamNames.push(examName);
                    
                    exam.questions.forEach((q, idx) => {
                        newQuestions.push({
                            ...q,
                            examName: examName,
                            id: `${examName}-${Date.now()}-${idx}`
                        });
                    });
                });
            }

            // Validate questions have required fields
            newQuestions.forEach((q, idx) => {
                if (!q.question || !q.answers || q.answers.length !== 4 || q.correctAnswer === undefined) {
                    throw new Error(`Question ${idx + 1} is missing required fields (question, answers array with 4 items, correctAnswer)`);
                }
            });

            // Merge new questions with existing ones
            allQuestions = [...allQuestions, ...newQuestions];
            
            // Merge exam names (avoid duplicates)
            newExamNames.forEach(name => {
                if (!examNames.includes(name)) {
                    examNames.push(name);
                }
            });

            // Save questions to storage
            saveQuestionsToStorage();
            
            // Populate exam dropdown
            populateExamDropdown();
            
            // Display stored exams list
            displayStoredExams();
            
            // Initialize quiz based on current mode
            handleModeChange();
            
            const totalQuestions = allQuestions.length;
            const totalExams = examNames.length;
            const newQuestionsCount = newQuestions.length;
            alert(`Successfully loaded ${newQuestionsCount} new question(s) from ${newExamNames.length} exam(s)!\n\nTotal: ${totalQuestions} questions across ${totalExams} exam(s).\nQuestions are now saved.`);
        } catch (error) {
            alert('Error loading file: ' + error.message);
            console.error(error);
        }
    };
    reader.readAsText(file);
}

function goBackToHome() {
    // Save current progress before going back
    saveProgress();
    
    // Show upload section
    uploadSection.style.display = 'block';
    quizSection.style.display = 'none';
    resultsSection.style.display = 'none';
    
    // Refresh the stored exams list
    displayStoredExams();
    
    // Check for resume option
    const hasProgress = loadProgress();
    if (hasProgress && examNames.length > 0) {
        resumeSection.style.display = 'block';
    } else {
        resumeSection.style.display = 'none';
    }
}

// Handle mode change
function handleModeChange() {
    const selectedMode = document.querySelector('input[name="mode"]:checked').value;
    currentMode = selectedMode;
    
    if (selectedMode === 'all') {
        examSelector.style.display = 'none';
        currentQuestions = [...allQuestions];
        startQuiz();
    } else if (selectedMode === 'rapidfire') {
        examSelector.style.display = 'none';
        startRapidFire();
    } else {
        examSelector.style.display = 'block';
        if (examNames.length > 0) {
            handleExamChange();
        }
    }
}

// Populate exam dropdown
function populateExamDropdown() {
    examDropdown.innerHTML = '';
    examNames.forEach((name, idx) => {
        const option = document.createElement('option');
        option.value = idx;
        option.textContent = name;
        examDropdown.appendChild(option);
    });
}

// Handle exam selection
function handleExamChange() {
    const selectedIndex = parseInt(examDropdown.value);
    currentExamIndex = selectedIndex;
    const selectedExamName = examNames[selectedIndex];
    
    currentQuestions = allQuestions.filter(q => q.examName === selectedExamName);
    startQuiz();
}

// Shuffle array function (Fisher-Yates algorithm)
function shuffleArray(array) {
    const shuffled = [...array]; // Create a copy to avoid modifying original
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

// Start quiz
function startQuiz() {
    if (currentQuestions.length === 0) {
        alert('No questions available. Please load a questions file.');
        return;
    }

    isRapidFire = false;
    
    // Randomize questions if checkbox is checked
    if (randomizeCheckbox.checked) {
        currentQuestions = shuffleArray(currentQuestions);
    }

    currentQuestionIndex = 0;
    userAnswers = {};
    score = { correct: 0, total: 0 };
    answerMappings = {}; // Reset answer mappings for new quiz
    incorrectQuestions = []; // Reset incorrect questions tracking
    
    uploadSection.style.display = 'none';
    quizSection.style.display = 'block';
    resultsSection.style.display = 'none';
    
    displayQuestion();
    updateNavigationButtons();
}

// Display current question
function displayQuestion() {
    const question = currentQuestions[currentQuestionIndex];
    const questionId = question.id || currentQuestionIndex;
    
    // Update question text
    questionText.textContent = question.question;
    
    // Handle image
    if (question.image) {
        const resolvedImagePath = resolveImagePath(question.image);
        if (resolvedImagePath) {
            questionImageContainer.style.display = 'block';
            questionImage.src = resolvedImagePath;
        } else {
            questionImageContainer.style.display = 'none';
        }
    } else {
        questionImageContainer.style.display = 'none';
    }
    
    // Handle answer randomization
    let answersToDisplay = question.answers;
    let correctAnswerIndex = question.correctAnswer;
    let mapping = null;
    
    if (randomizeAnswersCheckbox.checked) {
        // Check if we already have a mapping for this question (to maintain consistency)
        if (!answerMappings[questionId]) {
            // Create shuffled answers and mapping
            const indices = [0, 1, 2, 3];
            const shuffledIndices = shuffleArray(indices);
            
            // Create shuffled answers array
            answersToDisplay = shuffledIndices.map(origIdx => question.answers[origIdx]);
            
            // Create mapping: original index -> shuffled index
            const originalToShuffled = {};
            const shuffledToOriginal = {};
            shuffledIndices.forEach((origIdx, shuffledIdx) => {
                originalToShuffled[origIdx] = shuffledIdx;
                shuffledToOriginal[shuffledIdx] = origIdx;
            });
            
            // Update correct answer index to shuffled position
            correctAnswerIndex = originalToShuffled[question.correctAnswer];
            
            // Store mapping
            answerMappings[questionId] = {
                shuffledAnswers: answersToDisplay,
                originalToShuffled: originalToShuffled,
                shuffledToOriginal: shuffledToOriginal,
                correctAnswerShuffled: correctAnswerIndex
            };
        } else {
            // Use existing mapping
            mapping = answerMappings[questionId];
            answersToDisplay = mapping.shuffledAnswers;
            correctAnswerIndex = mapping.correctAnswerShuffled;
        }
    } else {
        // Clear mapping if randomization is disabled
        if (answerMappings[questionId]) {
            delete answerMappings[questionId];
        }
    }
    
    // Update answer buttons
    answerButtons.forEach((button, idx) => {
        const answerText = button.querySelector('.answer-text');
        answerText.textContent = answersToDisplay[idx];
        
        // Reset button state
        button.classList.remove('correct', 'incorrect', 'selected');
        button.disabled = false;
        
        // Show previous answer if exists
        if (userAnswers[questionId] !== undefined) {
            const userAnswerShuffled = userAnswers[questionId];
            const isCorrect = userAnswerShuffled === correctAnswerIndex;
            
            if (idx === userAnswerShuffled) {
                button.classList.add('selected');
                button.classList.add(isCorrect ? 'correct' : 'incorrect');
            }
            if (idx === correctAnswerIndex && !isCorrect) {
                button.classList.add('correct');
            }
            button.disabled = true;
        }
    });
    
    // Hide feedback initially
    feedback.style.display = 'none';
    
    // Update progress
    updateProgress();
}

// Handle answer click
function handleAnswerClick(event) {
    const button = event.currentTarget;
    const selectedIndex = parseInt(button.dataset.index);
    const question = currentQuestions[currentQuestionIndex];
    const questionId = question.id || currentQuestionIndex;
    
    // Don't allow changing answer if already answered
    if (userAnswers[questionId] !== undefined) {
        return;
    }
    
    // Get the correct answer index (may be shuffled)
    let correctAnswerIndex = question.correctAnswer;
    if (randomizeAnswersCheckbox.checked && answerMappings[questionId]) {
        correctAnswerIndex = answerMappings[questionId].correctAnswerShuffled;
    }
    
    // Store answer (in shuffled position if randomized)
    userAnswers[questionId] = selectedIndex;
    
    // Check if correct
    const isCorrect = selectedIndex === correctAnswerIndex;
    
    // Update score
    if (isCorrect) {
        score.correct++;
    } else {
        // Track incorrect question
        const labels = ['A', 'B', 'C', 'D'];
        let correctAnswerLabel = labels[correctAnswerIndex];
        let userAnswerLabel = labels[selectedIndex];
        
        // Get original answer text if shuffled
        let correctAnswerText = question.answers[question.correctAnswer];
        let userAnswerText = question.answers[selectedIndex];
        
        if (randomizeAnswersCheckbox.checked && answerMappings[questionId]) {
            const mapping = answerMappings[questionId];
            const originalCorrectIdx = mapping.shuffledToOriginal[correctAnswerIndex];
            const originalUserIdx = mapping.shuffledToOriginal[selectedIndex];
            correctAnswerText = question.answers[originalCorrectIdx];
            userAnswerText = question.answers[originalUserIdx];
        }
        
        incorrectQuestions.push({
            question: question.question,
            questionId: questionId,
            userAnswer: userAnswerLabel,
            userAnswerText: userAnswerText,
            correctAnswer: correctAnswerLabel,
            correctAnswerText: correctAnswerText,
            allAnswers: question.answers,
            image: question.image
        });
    }
    score.total++;
    
    // Auto-save progress
    saveProgress();
    
    // Show feedback (use shuffled index for display)
    showFeedback(isCorrect, correctAnswerIndex);
    
    // Update button styles
    answerButtons.forEach((btn, idx) => {
        btn.disabled = true;
        if (idx === selectedIndex) {
            btn.classList.add('selected');
            btn.classList.add(isCorrect ? 'correct' : 'incorrect');
        }
        if (idx === correctAnswerIndex && !isCorrect) {
            btn.classList.add('correct');
        }
    });
    
    updateScoreDisplay();
    
    // In rapid fire mode, automatically move to next question after a short delay
    if (isRapidFire) {
        setTimeout(() => {
            getNextRapidFireQuestion();
        }, 1500); // 1.5 second delay to see feedback
    } else {
        updateNavigationButtons();
    }
}

// Show feedback
function showFeedback(isCorrect, correctAnswerIndex) {
    feedback.style.display = 'block';
    feedback.className = 'feedback ' + (isCorrect ? 'correct' : 'incorrect');
    
    const labels = ['A', 'B', 'C', 'D'];
    if (isCorrect) {
        feedback.textContent = '‚úì Correct!';
    } else {
        feedback.textContent = `‚úó Incorrect. The correct answer is ${labels[correctAnswerIndex]}.`;
    }
}

// Update progress
function updateProgress() {
    if (isRapidFire) {
        progressFill.style.width = '100%';
        questionNumber.textContent = `Rapid Fire - Question ${score.total + 1}`;
    } else {
        const progress = ((currentQuestionIndex + 1) / currentQuestions.length) * 100;
        progressFill.style.width = progress + '%';
        questionNumber.textContent = `Question ${currentQuestionIndex + 1} of ${currentQuestions.length}`;
    }
}

// Update score display
function updateScoreDisplay() {
    scoreDisplay.textContent = `Score: ${score.correct}/${score.total}`;
}

// Update navigation buttons
function updateNavigationButtons() {
    if (isRapidFire) {
        prevButton.style.display = 'none';
        nextButton.style.display = 'none';
        finishButton.style.display = 'none';
        endRapidFireButton.style.display = 'inline-block';
        return;
    }
    
    prevButton.style.display = 'inline-block';
    nextButton.style.display = 'inline-block';
    endRapidFireButton.style.display = 'none';
    prevButton.disabled = currentQuestionIndex === 0;
    
    const question = currentQuestions[currentQuestionIndex];
    const questionId = question.id || currentQuestionIndex;
    const isAnswered = userAnswers[questionId] !== undefined;
    
    if (currentQuestionIndex === currentQuestions.length - 1) {
        nextButton.style.display = 'none';
        finishButton.style.display = isAnswered ? 'inline-block' : 'none';
    } else {
        nextButton.style.display = 'inline-block';
        finishButton.style.display = 'none';
    }
}

// Go to previous question
function goToPreviousQuestion() {
    if (currentQuestionIndex > 0) {
        currentQuestionIndex--;
        displayQuestion();
        updateNavigationButtons();
        saveProgress();
    }
}

// Go to next question
function goToNextQuestion() {
    const question = currentQuestions[currentQuestionIndex];
    const questionId = question.id || currentQuestionIndex;
    
    // Check if current question is answered
    if (userAnswers[questionId] === undefined) {
        alert('Please select an answer before proceeding.');
        return;
    }
    
    if (currentQuestionIndex < currentQuestions.length - 1) {
        currentQuestionIndex++;
        displayQuestion();
        updateNavigationButtons();
        saveProgress();
    }
}

// Finish quiz
function finishQuiz() {
    // Check if all questions are answered
    const unanswered = currentQuestions.filter((q, idx) => {
        const questionId = q.id || idx;
        return userAnswers[questionId] === undefined;
    });
    
    if (unanswered.length > 0) {
        if (!confirm(`You have ${unanswered.length} unanswered question(s). Finish anyway?`)) {
            return;
        }
    }
    
    showResults();
}

// Show results
function showResults() {
    quizSection.style.display = 'none';
    resultsSection.style.display = 'block';
    
    const total = isRapidFire ? score.total : currentQuestions.length;
    const correct = score.correct;
    const incorrect = total - correct;
    const percentage = total > 0 ? Math.round((correct / total) * 100) : 0;
    
    document.getElementById('total-questions').textContent = total;
    document.getElementById('correct-answers').textContent = correct;
    document.getElementById('incorrect-answers').textContent = incorrect;
    document.getElementById('percentage-score').textContent = percentage + '%';
    
    // Save score for the current exam (only for individual exams, not "All Questions" mode)
    if (!isRapidFire && currentMode === 'exam' && examNames.length > 0) {
        const examName = examNames[currentExamIndex];
        if (examName) {
            saveExamScore(examName, {
                percentage: percentage,
                correct: correct,
                total: total
            });
            
            // Update the stored exams display to show new score
            displayStoredExams();
        }
    }
    
    // Display incorrect questions
    displayIncorrectQuestions();
}

function displayIncorrectQuestions() {
    if (incorrectQuestions.length === 0) {
        incorrectQuestionsSection.style.display = 'none';
        return;
    }
    
    incorrectQuestionsSection.style.display = 'block';
    incorrectQuestionsList.innerHTML = '';
    
    incorrectQuestions.forEach((item, idx) => {
        const questionCard = document.createElement('div');
        questionCard.className = 'incorrect-question-card';
        questionCard.style.cssText = 'margin-bottom: 20px; padding: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 10px;';
        
        let imageHtml = '';
        if (item.image) {
            const resolvedImagePath = resolveImagePath(item.image);
            if (resolvedImagePath) {
                imageHtml = `<div style="text-align: center; margin-bottom: 15px;"><img src="${resolvedImagePath}" alt="Question diagram" style="max-width: 100%; max-height: 300px; border-radius: 8px;" /></div>`;
            }
        }
        
        questionCard.innerHTML = `
            <div style="font-weight: bold; color: #856404; margin-bottom: 10px; font-size: 1.1em;">
                Question ${idx + 1}
            </div>
            ${imageHtml}
            <div style="margin-bottom: 15px; font-size: 1.05em; line-height: 1.6;">
                ${item.question}
            </div>
            <div style="background: #f8d7da; padding: 12px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid #dc3545;">
                <strong style="color: #721c24;">‚ùå Your Answer:</strong> <span style="color: #721c24;">${item.userAnswer}) ${item.userAnswerText}</span>
            </div>
            <div style="background: #d4edda; padding: 12px; border-radius: 8px; border-left: 4px solid #28a745;">
                <strong style="color: #155724;">‚úì Correct Answer:</strong> <span style="color: #155724;">${item.correctAnswer}) ${item.correctAnswerText}</span>
            </div>
        `;
        
        incorrectQuestionsList.appendChild(questionCard);
    });
}

// Rapid Fire Functions
function startRapidFire() {
    if (allQuestions.length === 0) {
        alert('No questions available. Please load a questions file.');
        return;
    }
    
    isRapidFire = true;
    rapidFireQuestions = [...allQuestions];
    rapidFireAnswered = new Set();
    incorrectQuestions = [];
    currentQuestionIndex = 0;
    userAnswers = {};
    score = { correct: 0, total: 0 };
    answerMappings = {};
    
    uploadSection.style.display = 'none';
    quizSection.style.display = 'block';
    resultsSection.style.display = 'none';
    
    getNextRapidFireQuestion();
    updateNavigationButtons();
}

function getNextRapidFireQuestion() {
    // Filter out questions that have already been shown
    const availableQuestions = rapidFireQuestions.filter(q => {
        const qId = q.id || rapidFireQuestions.indexOf(q);
        return !rapidFireAnswered.has(qId);
    });
    
    // If all questions have been shown, reset the set
    if (availableQuestions.length === 0) {
        rapidFireAnswered.clear();
        availableQuestions.push(...rapidFireQuestions);
    }
    
    // Randomly select a question
    const randomIndex = Math.floor(Math.random() * availableQuestions.length);
    const selectedQuestion = availableQuestions[randomIndex];
    const questionId = selectedQuestion.id || rapidFireQuestions.indexOf(selectedQuestion);
    
    // Mark as answered
    rapidFireAnswered.add(questionId);
    
    // Set as current question
    currentQuestions = [selectedQuestion];
    currentQuestionIndex = 0;
    
    // Display the question
    displayQuestion();
    updateScoreDisplay();
}

function endRapidFire() {
    if (score.total === 0) {
        if (!confirm('You haven\'t answered any questions yet. End rapid fire anyway?')) {
            return;
        }
    }
    
    isRapidFire = false;
    showResults();
}

// Restart quiz
function restartQuiz() {
    resultsSection.style.display = 'none';
    uploadSection.style.display = 'block';
    fileInput.value = '';
    
    // Check if questions are saved
    checkForSavedData();
    
    // Reset current quiz state but keep saved questions
    currentQuestionIndex = 0;
    userAnswers = {};
    score = { correct: 0, total: 0 };
    currentQuestions = [];
    
    // Clear progress but keep questions
    localStorage.removeItem('quizProgress');
}

// Review answers
function reviewAnswers() {
    resultsSection.style.display = 'none';
    quizSection.style.display = 'block';
    currentQuestionIndex = 0;
    displayQuestion();
    updateNavigationButtons();
}

